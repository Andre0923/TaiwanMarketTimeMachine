
> **核心精神**：系統只有一個真相，就是 `specs/system/spec.md`。所有的開發都是為了更新這個真相，而不是繞過它。
## 1. 為什麼我們要這樣做？ (The Why)
在 AI 輔助開發的時代，最大的風險是 AI 隨意修改程式碼導致與原始設計脫鉤。我們採用 **SDD (Specification-Driven Development)** 是為了確保：
1. **規格即程式碼**：所有的行為變更都必須先反映在文件上。
2. **唯一真相**：避免需求文件 (PRD)、規格文件 (Spec) 與程式碼 (Code) 三者不一致。
3. **AI 防護欄**：透過多層級的規範，防止 AI 產生幻覺或破壞系統架構。

---
## 2. 我們的三層防禦架構 (The Architecture)
為了讓 AI (GitHub Copilot / Spec Kit Agent) 乖乖聽話，我們設計了三道防線：
### 第一層：全域防護 (Global Guardrails)
- **文件**：`.github/copilot-instructions.md`
- **作用**：這是 Copilot 的「緊箍咒」。無論你是否在使用 Spec Kit 指令，只要你在 VS Code 開啟 Copilot Agent，它就會生效。
- **核心規則**：
    - **NEVER** 直接修改 `specs/system/` 下的檔案（除非正在執行 Unify Flow）。
    - 遇到不確定的邏輯，必須 **ASK** 人類，不能自行假設。
### 第二層：專案憲法 (The Constitution)
- **文件**：`.specify/memory/constitution.md`
- **作用**：這是 Spec Kit 工具運作時的「法律」。它定義了目錄結構、User Story 格式 (BDD) 以及 Unify Flow 的詳細條款。
- **核心規則**：
    - 開發必須遵循 `System` (現狀) vs `Feature` (變更) 的雙層結構。
    - 嚴禁將 `docs/` 下的規劃文件視為系統的唯一真相。
### 第三層：操作 SOP (Standard Procedures)
- **文件**：`specs/system/unify-flow.md`
- **作用**：這是將開發成果「合法化」的唯一途徑。
- **核心規則**：Feature 分支要合併回 Main 之前，必須執行 Unify Flow，將變更寫入 System Spec。

---
## 3. 目錄結構與職責 (Directory Map)
請將此地圖印在腦海中：

|**目錄**|**狀態**|**說明**|**能改嗎？**|
|---|---|---|---|
|`specs/system/`|🔴 **唯一真相**|代表系統「現在」的行為與設計。|**NO** (除非跑 Unify Flow)|
|`specs/features/`|🟡 **開發遊樂場**|代表「這次」要改什麼。包含 `spec.md`, `plan.md`, `tasks.md`。|**YES** (這是你的工作區)|
|`docs/`|🟢 **參考資料**|PRD、User Story 清單。僅供規劃參考，**不是**執行依據。|YES (僅供參考)|
|`src/`|🔵 **實作**|程式碼必須完全符合 `specs` 的描述。|YES (但在測試通過後)|

---
## 4. 開發過程中的規格調整指南 (The Golden Rules)
這部分最重要，請根據不同情境採取行動。
### 情境 A：開發中 Debug (Feature 分支)
- **如果是實作寫錯**：👉 **只改程式碼**。
- **如果是 Spec 寫錯/漏寫**：👉 **先改 Feature Spec**，再改程式碼。
- 🔴 **絕對禁止**：直接去改 `specs/system/`。
### 情境 B：開發中想加功能 (Scope Management)
- **自然演化** (補充細節/修正描述)：
    - 👉 直接修改當前 Feature 的 `spec.md`。
- **需求擴張** (新增 User Goal/影響其他模組)：
    - 👉 **停！** 這是新 Feature。請開一個新的 Feature 目錄 (`/speckit.specify`)。
### 特別條款：UI 行為同步 (UI is Spec)
> 🔑 **核心原則**：UI 行為變更 = 規格變更，不得僅改程式碼。
- **開發中**：允許 UI 邊做邊修，但在整合前 **MUST** 把最終行為回填至 `Feature Spec`。
- **Debug 時**：若 UI 需要調整，必須修改 `Feature Spec`（不是 System Spec）。
- **Unify Flow 去處**：
    - UI **行為** (Behavior) → 寫入 `specs/system/spec.md`。
    - UI **結構** (Structure) → 寫入 System Design (如 `data-model` 或 `flows`)。
### 情境 C：Main 分支發現 Bug (Hotfix)

|**Bug 類型**|**分支命名**|**是否需要 Feature 目錄？**|
|---|---|---|
|**實作 Bug** (Code 錯，Spec 對)|`fix/xxx`|❌ 不用 (直接修 Code 發 PR)|
|**規格 Bug** (Spec 定義就有誤)|`hotfix/xxx`|✅ **要** (需建 `specs/features` 並跑 Unify Flow)|

---
## 5. Unify Flow：讓變更生效的儀式
當你的 Feature 開發完成，準備發 PR 之前，必須執行 **Unify Flow**。
**指令**：(對 AI 說)「請執行 Unify Flow，處理 `specs/features/NNN-你的功能/`」
**合併原則**：
1. **System Spec 是基底**，**Feature Spec 是更新包**。
2. **衝突時以 Feature Spec 為準**（代表最新設計意圖）。
3. AI 完成後，原本的 Feature 目錄會被移到 `specs/history/` 封存。

---
## 6. 懶人包總結 (TL;DR)
1. **Copilot 不乖？** 檢查 `.github/copilot-instructions.md`。
2. **UI 改了？** 記得回填 Feature Spec，不要只改 Code。
3. **想加功能？** 範圍太大就開新 Feature，不要偷渡。
4. **發 PR 前？** 務必確認已執行 Unify Flow，且 `/speckit.analyze` 全綠。